"""
Check Command - CI/CD Gate for Pre-Merge Impact Analysis.
Standardized output version.
"""

import sys
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, List, Tuple

import click
from pydantic import BaseModel, Field

from ..renderers import JsonRenderer


# --- API Models (External Contract) ---
class CheckResultStatus(str, Enum):
    PASS = "PASS"
    BLOCKED = "BLOCKED"
    WARN = "WARN"


class ApiChangedFile(BaseModel):
    path: str
    change_type: str


class ApiViolation(BaseModel):
    rule: str
    severity: str
    message: str


class CheckResponse(BaseModel):
    """
    Standardized response for check command.
    Maps internal CheckReport to external API contract.
    """

    result: CheckResultStatus
    exit_code: int
    changed_files_count: int
    critical_count: int
    high_count: int
    violations: List[ApiViolation] = Field(default_factory=list)
    details_url: str | None = None


# --- Internal Domain Models ---
class CheckResult(Enum):
    PASS = 0
    BLOCKED = 1
    WARN = 2


@dataclass
class ChangedFile:
    path: str
    change_type: str
    old_path: str | None = None


@dataclass
class CheckReport:
    """Internal report generated by the analysis engine."""

    result: CheckResult = CheckResult.PASS
    changed_files: List[ChangedFile] = field(default_factory=list)
    critical_count: int = 0
    high_count: int = 0
    violations: List[Any] = field(default_factory=list)


class _null_context:
    """Helper for non-capture mode."""

    def __enter__(self):
        pass

    def __exit__(self, *args):
        pass


# =============================================================================
# CLI Command
# =============================================================================


@click.command()
@click.option("--diff", "diff_file", type=click.Path(exists=True))
@click.option("--git-diff", "git_diff", nargs=2)
@click.option("--fail-if-critical", is_flag=True)
@click.option("--json", "as_json", is_flag=True, help="Output as JSON (Standard Envelope)")
@click.option("--format", "output_format", type=click.Choice(["text", "markdown"]), default="text")
@click.option("--quiet", "-q", is_flag=True)
def check(
    diff_file: str | None,
    git_diff: Tuple[str, str] | None,
    fail_if_critical: bool,
    as_json: bool,
    output_format: str,
    quiet: bool,
):
    """Run pre-merge impact analysis."""
    renderer = JsonRenderer("check")

    # Context handling: Capture stdout/stderr only if JSON output is requested
    context_manager = renderer.capture() if as_json else _null_context()

    error_to_report = None
    api_response = None

    with context_manager:
        try:
            # 1. Get changed files
            changed_files = []
            if diff_file:
                # Placeholder: In prod, parse the diff file
                changed_files = [ChangedFile("file.py", "modified")]
            elif git_diff:
                # Placeholder: In prod, run git diff command
                changed_files = [ChangedFile("app.py", "modified")]
            else:
                changed_files = []

            # 2. Create Report (Mocked logic for now, replacing previous inline class)
            # In a real implementation, this would come from an Engine.analyze() call
            report = CheckReport(
                result=CheckResult.PASS,
                changed_files=changed_files,
                critical_count=0,
                high_count=0,
                violations=[],
            )

            # Apply failure logic
            if fail_if_critical and report.critical_count > 0:
                report.result = CheckResult.BLOCKED

            # 3. Map to API Model
            api_response = CheckResponse(
                result=CheckResultStatus[report.result.name],
                exit_code=report.result.value,
                changed_files_count=len(report.changed_files),
                critical_count=report.critical_count,
                high_count=report.high_count,
                violations=[],
            )

        except Exception as e:
            error_to_report = e

    # Render Output
    if as_json:
        if error_to_report:
            renderer.render_error(error_to_report)
            sys.exit(1)
        elif api_response:
            renderer.render_success(api_response)
            sys.exit(api_response.exit_code)
    else:
        # Legacy Text Output
        if error_to_report:
            if not quiet:
                click.echo(f"Error: {error_to_report}", err=True)
            sys.exit(1)

        if not quiet and api_response:
            click.echo(f"Result: {api_response.result.value}")

        if api_response:
            sys.exit(api_response.exit_code)

        sys.exit(1)
