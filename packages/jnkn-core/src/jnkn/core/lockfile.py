"""
Lockfile management for jnkn.

Provides deterministic builds by pinning git dependency versions to specific
commit SHAs. The lockfile (jnkn.lock) is auto-generated and should be committed
to version control.

Format:
    The lockfile uses TOML format with a list of [[package]] entries, each
    containing the resolved git SHA and timestamp.
"""

from __future__ import annotations

import sys
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Iterator, List, Optional

if sys.version_info >= (3, 11):
    import tomllib
else:
    import tomli as tomllib

try:
    import tomli_w
except ImportError:
    tomli_w = None  # type: ignore


LOCKFILE_VERSION = 1
LOCKFILE_HEADER = """# This file is auto-generated by jnkn. Do not edit manually.
# Run `jnkn lock` to regenerate.
#
# See https://jnkn.dev/docs/lockfile for more information.
"""


@dataclass
class LockedPackage:
    """
    A locked dependency with pinned version.

    Attributes:
        name: Dependency name (matches key in jnkn.toml).
        source: Source type ("git" or "local").
        git: Git repository URL (for git dependencies).
        branch: Original branch name (for reference).
        tag: Original tag name (for reference).
        rev: Pinned commit SHA.
        resolved_at: Timestamp when this version was locked.
    """

    name: str
    source: str
    git: Optional[str] = None
    branch: Optional[str] = None
    tag: Optional[str] = None
    rev: Optional[str] = None
    resolved_at: Optional[datetime] = None

    def to_dict(self) -> dict:
        """
        Convert to dictionary for TOML serialization.

        Returns:
            Dictionary with non-None values only.
        """
        result = {"name": self.name, "source": self.source}

        if self.git:
            result["git"] = self.git
        if self.branch:
            result["branch"] = self.branch
        if self.tag:
            result["tag"] = self.tag
        if self.rev:
            result["rev"] = self.rev
        if self.resolved_at:
            result["resolved_at"] = self.resolved_at.isoformat()

        return result

    @classmethod
    def from_dict(cls, data: dict) -> "LockedPackage":
        """
        Create from TOML dictionary.

        Args:
            data: Dictionary from parsed TOML.

        Returns:
            LockedPackage instance.
        """
        resolved_at = None
        if "resolved_at" in data:
            resolved_at_str = data["resolved_at"]
            if isinstance(resolved_at_str, str):
                # Handle ISO format with or without timezone
                try:
                    resolved_at = datetime.fromisoformat(resolved_at_str.replace("Z", "+00:00"))
                except ValueError:
                    pass
            elif isinstance(resolved_at_str, datetime):
                resolved_at = resolved_at_str

        return cls(
            name=data["name"],
            source=data.get("source", "git"),
            git=data.get("git"),
            branch=data.get("branch"),
            tag=data.get("tag"),
            rev=data.get("rev"),
            resolved_at=resolved_at,
        )

    @property
    def short_rev(self) -> str:
        """Get shortened commit SHA (8 chars)."""
        if self.rev:
            return self.rev[:8]
        return "unknown"


@dataclass
class Lockfile:
    """
    Parsed jnkn.lock file.

    The lockfile pins all git dependencies to specific commit SHAs, ensuring
    reproducible builds across machines and CI environments.

    Attributes:
        version: Lockfile format version.
        packages: List of locked packages.
    """

    version: int = LOCKFILE_VERSION
    packages: List[LockedPackage] = field(default_factory=list)

    @classmethod
    def load(cls, path: Path) -> "Lockfile":
        """
        Load lockfile from disk.

        Args:
            path: Path to jnkn.lock file.

        Returns:
            Lockfile instance (empty if file doesn't exist).
        """
        if not path.exists():
            return cls()

        try:
            with open(path, "rb") as f:
                data = tomllib.load(f)
        except Exception:
            return cls()

        packages = [LockedPackage.from_dict(pkg) for pkg in data.get("package", [])]

        return cls(
            version=data.get("version", LOCKFILE_VERSION),
            packages=packages,
        )

    def save(self, path: Path) -> None:
        """
        Write lockfile to disk.

        Args:
            path: Path to write jnkn.lock file.

        Raises:
            ImportError: If tomli_w is not installed.
        """
        if tomli_w is None:
            # Fallback to manual TOML generation
            self._save_manual(path)
            return

        data = {
            "version": self.version,
            "package": [pkg.to_dict() for pkg in self.packages],
        }

        with open(path, "wb") as f:
            f.write(LOCKFILE_HEADER.encode("utf-8"))
            f.write(b"\n")
            tomli_w.dump(data, f)

    def _save_manual(self, path: Path) -> None:
        """
        Manual TOML generation fallback when tomli_w is not available.

        Args:
            path: Path to write jnkn.lock file.
        """
        lines = [LOCKFILE_HEADER, f"version = {self.version}", ""]

        for pkg in self.packages:
            lines.append("[[package]]")
            lines.append(f'name = "{pkg.name}"')
            lines.append(f'source = "{pkg.source}"')
            if pkg.git:
                lines.append(f'git = "{pkg.git}"')
            if pkg.branch:
                lines.append(f'branch = "{pkg.branch}"')
            if pkg.tag:
                lines.append(f'tag = "{pkg.tag}"')
            if pkg.rev:
                lines.append(f'rev = "{pkg.rev}"')
            if pkg.resolved_at:
                lines.append(f'resolved_at = "{pkg.resolved_at.isoformat()}"')
            lines.append("")

        with open(path, "w") as f:
            f.write("\n".join(lines))

    def get_package(self, name: str) -> Optional[LockedPackage]:
        """
        Get a locked package by name.

        Args:
            name: Dependency name to look up.

        Returns:
            LockedPackage if found, None otherwise.
        """
        for pkg in self.packages:
            if pkg.name == name:
                return pkg
        return None

    def update_package(self, package: LockedPackage) -> None:
        """
        Update or add a package to the lockfile.

        If a package with the same name exists, it will be replaced.

        Args:
            package: The package to add or update.
        """
        for i, pkg in enumerate(self.packages):
            if pkg.name == package.name:
                self.packages[i] = package
                return
        self.packages.append(package)

    def remove_package(self, name: str) -> bool:
        """
        Remove a package from the lockfile.

        Args:
            name: Name of the package to remove.

        Returns:
            True if package was found and removed, False otherwise.
        """
        for i, pkg in enumerate(self.packages):
            if pkg.name == name:
                del self.packages[i]
                return True
        return False

    def iter_packages(self) -> Iterator[LockedPackage]:
        """
        Iterate over all locked packages.

        Yields:
            LockedPackage instances.
        """
        yield from self.packages

    def is_stale(self, name: str, current_sha: str) -> bool:
        """
        Check if a locked package is out of date.

        Args:
            name: Package name.
            current_sha: The current resolved SHA.

        Returns:
            True if the locked SHA differs from current SHA.
        """
        locked = self.get_package(name)
        if locked is None:
            return True
        return locked.rev != current_sha

    def get_stale_packages(self, current_shas: dict[str, str]) -> List[str]:
        """
        Get list of packages that are stale.

        Args:
            current_shas: Dict mapping package names to their current SHAs.

        Returns:
            List of package names that are stale.
        """
        stale = []
        for pkg in self.packages:
            if pkg.name in current_shas:
                if pkg.rev != current_shas[pkg.name]:
                    stale.append(pkg.name)
        return stale

    def __len__(self) -> int:
        """Return number of locked packages."""
        return len(self.packages)

    def __contains__(self, name: str) -> bool:
        """Check if a package is locked."""
        return self.get_package(name) is not None


def create_locked_package(
    name: str,
    git_url: str,
    rev: str,
    branch: Optional[str] = None,
    tag: Optional[str] = None,
) -> LockedPackage:
    """
    Factory function to create a locked package with current timestamp.

    Args:
        name: Dependency name.
        git_url: Git repository URL.
        rev: Commit SHA to pin.
        branch: Optional branch name.
        tag: Optional tag name.

    Returns:
        LockedPackage with resolved_at set to now.
    """
    return LockedPackage(
        name=name,
        source="git",
        git=git_url,
        branch=branch,
        tag=tag,
        rev=rev,
        resolved_at=datetime.now(timezone.utc),
    )
